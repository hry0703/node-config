- 最终可以完美解答 当输入url到页面展现的所有过程?  
- tcp/ip协议簇 （我们要学的就是相关的常见协议）


> OSI七层模型 （理想化的模型） 通过这七层模型将网络进行了整体的划分 （通信的过程分成了七个层级） 就是分而治之。 将一个复杂的模型简单化。   下层是为了上层所服务的 

底层->上层
- 物理层 （核心就是传输比特流，将数据从一个地方传递到另一个地方）， 物理设备（双绞线，光纤，无线...）
- 数据链路层 (主要的作用就是关心两个设备之间的数据传递)，建立逻辑连接，将数据包装成帧（差错校验， 保证可靠传输）  mac地址
----------局域网----------
- 网络层 （做路由的主要就是路由的选择）， 就是寻找地址，定位的到位（寻找最短路线），将数据包传递过去  ip包
- 传输层 （主要作用就是传输，将数据分段、重组、可靠传输）  网络层不太可靠，需要在传输层上做一些可靠传输。  传递的叫 数据段
-------------------------
- 会话层 建立会话
- 表示层 数据的表示方式 （将数据进行编码，处理等等）
- 应用层 用户使用的接口 http

> 给对方发送信件的过程 我们就可以用这七层来描述

- 1.应用层： 我需要先想到我要给对方写的内容是什么  应用层数据     （报文）
- 2.表示层： 这个信 用什么方式来写 json，xml，str，。。。 将数据按照特定的方式表示出来
- 3.会话层： 告诉女朋友我给你写信了，到时候你收到看一下。

----用户准备的数据-----
- 4.传输层： 找个快递我家在504房间，我需要把信寄给 701 （端口号）   数据段（端口号）
- 5.网络层:  给我个具体的门牌号 xxx省xxx市xxx区xxx街道xxx小区    ip包 (数据段（端口号）+ ip地支)
- 6.数据链路层： 需要我们将包裹，给总部，总部会根据地址进行划分，根据对应的快递路线来进行传输   数据帧（ip包 (数据段（端口号）+ ip地支) + mac地址）
- 7.物理层： 设备、飞机、汽车 ，将数据传递过去

> 真正使用的时候 一般是四层、五层协议  （报文） -》 数据段（端口号） -》   ip包  -》  数据帧 -》 传输


## 地址
- 通信是通过ip地址来查找对应的mac地址，ip地址是可以变化的，mac地址是无法变化的。 ip地址是逻辑地址，mac地址是物理地址
- mac 地址就是每个通信的设备 都是通过网卡来通信的，每个网卡都有自己的mac地址（原则上唯一）  mac地址-》 mac地址的通信
- ip地址   ipv4 (192.168.1.1) (我们的网络可以划分子网) 最大就是42亿 ipv6   

1234:1234:1234:1234:123...  8 * 16 = 128  2**128  

> 寻址 寻的是mac地址，通过ip来寻找mac地址

- 物理层： 
    - 中继器 2口，延长数据的传输距离，可以放大信号的功能
    - 集线器 多个口的中继器，可以通过它来让多个人进行数据的传输 （广播通信、不安全，浪费流浪，没有记录每个人的信息）
- 数据链路层: 交换机： 记住每个人的mac地址， 还有对应的插在哪个端口上了 .  可以记录每个设备和端口之间的关系，第一次通信通过广播后面就可以直接通信了，不需要广播 （只能是局域网）
- 网络层: 路由器上网的  wan口连接网线的  lan口 （没有wan口的路由器就是小型的交互机）  链接两个不同的子网 （网关）



> 数据传输就是根据ip地址来进行寻址，通过链路层来进行传递 （通过mac地址之间的通信）


## TCP/IP协议簇（是整个osi模型里的所有协议）

> Transmission Control Protocol  / Internet   什么协议？ 协议是用来干嘛的 （规范，约定好了的）

> 我们一般来说是三层以上才有“协议”
- 物理层，链路层： 多数都指代的事物理设备 （一般我们在七层网络协议中 最底下这两层，都没有协议都是在这两层之上的）
- 网络层 IP协议， （ARP协议  Address Resolution Protocol (通过ip地址来寻找mac地址 只能在局域网下使用)，应该是二层的协议， 归纳成三层协议）
- 传输层： TCP ，  UDP
- 应用层： HTTP， DNS,  DHCP ....


### ARP协议 （ip地址来寻找mac地址） 
> 有缓存： ip -》 mac地址

> 交换机： mac地址 -》 端口


### DNS (Domain Name System) 域名系统 
DNS 是基于udp （不用建立连接 性能高）

> 当用户输入一个域名的时候按回车发生什么？  mac地址？（长） -》 ip地址（长） -》 域名（短）

> 域名 （顶级域名 test.baidu.com 几个店就是几级域名 2级域名,  .com .cn 顶级域名）  

> dns解析的过程是一个递归查找的过程    我.哈尔滨.黑龙江.中国 域名。   默认当我们输入一个域名的时候 （不考虑缓存） 此时会找到离自己最近的根服务器。 通过根服务器.com 将.com的ip地址返回给你， 在像这个ip地址发送请求获取到这个ip地址中的baidu的ip地址

公网ip地址

dns 缓存
根服务器 确定了.com
.com  xxx.xxx.xxx.xxx
.baidu.com  xxx.qqq.qqq.qqq
baidu.com  www.qqqq.qqq.qqq.qqq


www.baidu.com
baidu.com


## NAT  （我们的内网地址无法直接访问外网，就需要将本地的地址转换成外网地址）
将内网地址转换成外网地址的作用 （如果用户量大划分子网）



##  TCP 和 UDP

###  TCP (可靠，且效率低)  
- 在复杂的网络中数据是容易丢失的， 我们需要再网络的基础上增加一个可靠的传输 （三次握手，如果丢包了，会进行重传，可以控制传输速率）
- tcp是一个双工通信协议 （单工，半双工 ，双工）。  可以通过tcp来进行可靠的双向通信


面向链接的 TCP数据段


**为什么是三次握手？  因为tcp是双工的，为了保证双方都能互相通信必须三次**

- 我能不能给你发个短信以后
- 可以， 那我能不能给你发啊？  （2条含义 确认，询问）
- 好的


三次握手
- 客户端会发送握手请求 (客户端序列号seq = 0)  (服务端也有一个seq = 0)
- 服务端收到之后，会在客户端的seq基础上+1， 作为应答表示我已经收到了这次握手的请求了， 我要告诉服务端我的序号是多少0
- 客户端收到后，会在服务端的序列号上+1 作为ack ack = 1 ， 并且用服务端的ack作为客户端的seq = 1

> 服务端会和客户端协商窗口大小。


数据传输 
- 客户端给服务端说hello
- 服务端给客户端说hi

核心是客户端给服务端发送消息的时候 会传递len属性，和自己的seq=1，和对方的seq=ack, 对方收到后会基于你传递的seq + len = ack， 并且用你传递的ack 作为我自己的seq

服务端给客户端发送消息，将自己的seq，传递过去，将ack的值（对方的seq）传递过去 ,以及len， 对方收到后将对方的seq + len = ack ，  并且用你传递的ack 作为我自己的seq

> 可以维护上方的序列号， 双方都能知道该从几开始发消息了


## 分手的时候 
- 双方的seq + 1， 达到分手的目的
- 为什么分手要四次？

> 分手的时候 需要等待消息发送完毕后，在询问，但是收到分手消息时，要立刻应答否则会认为丢包了（重发的情况）


tcp就是安全可靠谱，具备丢包重传你的能力，而且慢 （策略 慢开始）


## udp 
- 无连接的，不可靠，可以丢， 快 




## tcp队头阻塞问题
- tcp是有序传输的，我们需要将数据接收后进行，组合，组合方式靠seq (问题在于如果第一个收不到，此时无法发送后面的内容)
- 发送和接收，都有滑动窗口的概念，发送方的滑动窗口是为了，限制传输的速率，对方收到后，窗口会向后滑动，在窗口内的表示正在发送的数据，接收方也有一个窗口，用来描述接收了多少数据，还可以告诉发送端自己的窗口大小，一旦窗口为0则停止发送。等待缓存区的数据被上层应用读取后，会主动通知发送方窗口大小。（客户端也会主动发送探测包，来获取接收方的窗口大小） 控制速率 

> 我们希望能找到带宽传输的一个合适的值 （拥塞窗口来进行试探）

## tcp的慢开始问题
- （慢开始）默认有一个ssthreash (达到此值时进入拥塞避免) 指数增长，线性增长。 如果丢包了（从0开始）？ 如果丢包了就真的表示拥塞了吗? (如果丢包就从0重新开始太浪费性能) 别回到0。 所以针对收到的内容会进行ack确认，如果丢了包，达到了3次ack还没有收到。则会快速重新传包（避免慢开始或者更新cwnd的值）
- tcp初次创建的时候 就是慢 （1个域名可以创建6个tcp请求，多个tcp请求都会有慢开始的情况，竞争问题）

## 如果采用tcp数据比较小的话，还会出现浪费空间的问题
- 当发送小数据的时候，我们会将多个小包进行粘包 （默认node中采用的事nagle算法，一段时间内发送的过程中，只能有一个小包， 也可以自己制定cork算法，尽可能拼接一起发送）


> tcp滑动窗口来控制传输速率，慢开始和快重传(控制速率), 粘包，将多个包粘贴在一起。

> 慢开始、队头阻塞、tcp关闭后端口累计的问题也解决不了。